import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers":
    "authorization, x-client-info, apikey, content-type, x-supabase-client-platform, x-supabase-client-platform-version, x-supabase-client-runtime, x-supabase-client-runtime-version",
};

/** Parse conditional DSL expression into structured conditions */
function parseDSLConditions(expression: string): any[] | null {
  const CONDITION_RE = /^(\w+):(\w+)\s+if\s+(\w+)\s*(>=|<=|==|>|<)\s*([\d.]+)$/;
  const OTHERWISE_RE = /^(\w+):(\w+)\s+otherwise$/;
  const VALID_VARS = ['sentiment', 'proximity', 'tempo', 'energy', 'volume'];

  const lines = expression.trim().split('\n').map(l => l.trim()).filter(Boolean);
  if (lines.length === 0) return null;

  const conditions: any[] = [];
  for (const line of lines) {
    const cm = line.match(CONDITION_RE);
    if (cm) {
      const [, action, moveName, variable, operator, threshold] = cm;
      if (!VALID_VARS.includes(variable)) return null;
      conditions.push({ action, moveName, variable, operator, threshold: parseFloat(threshold) });
      continue;
    }
    const om = line.match(OTHERWISE_RE);
    if (om) {
      conditions.push({ action: om[1], moveName: om[2], otherwise: true });
      continue;
    }
    return null; // not DSL
  }
  return conditions.length > 0 ? conditions : null;
}

Deno.serve(async (req) => {
  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const { moveName, description, videoHash, creator, royaltyPercent, mintPubkey, videoHashCid } =
      await req.json();

    if (!moveName || !creator) {
      return new Response(
        JSON.stringify({ error: "moveName and creator are required" }),
        { status: 400, headers: { ...corsHeaders, "Content-Type": "application/json" } }
      );
    }

    const conditions = videoHash ? parseDSLConditions(videoHash) : null;

    const metadata = {
      name: moveName,
      symbol: "MOVE",
      description: description || `Dance move NFT: ${moveName}`,
      image: "",
      external_url: "https://moveregistry.lovable.app",
      attributes: [
        { trait_type: "Creator", value: creator },
        { trait_type: "Royalty", value: `${royaltyPercent ?? 5}%` },
        { trait_type: "Video Hash", value: videoHash || "" },
        ...(videoHashCid ? [{ trait_type: "Video CID", value: videoHashCid }] : []),
        ...(conditions ? [{ trait_type: "Conditional DSL", value: "true" }] : []),
      ],
      properties: {
        category: "video",
        creators: [{ address: creator, share: 100 }],
      },
      seller_fee_basis_points: (royaltyPercent ?? 5) * 100,
      ...(conditions ? { conditions } : {}),
    };

    // OpenClaw skill.json
    const skillJson = {
      name: moveName,
      version: "1.0.0",
      description: description || `Dance move NFT: ${moveName}`,
      homepage: "https://moveregistry.lovable.app",
      metadata: {
        openclaw: {
          category: "choreography",
          mint: mintPubkey || "",
          creator,
          royalty_bps: (royaltyPercent ?? 5) * 100,
          ...(conditions ? { conditions } : {}),
        },
      },
    };

    // SKILL.md
    const skillMd = `# ${moveName}

> ${description || `Dance move NFT: ${moveName}`}

## Creator
\`${creator}\`

## Royalty
${royaltyPercent ?? 5}%${mintPubkey ? `\n\n## Mint\n\`${mintPubkey}\`` : ''}

## Expression
\`\`\`
${videoHash || 'N/A'}
\`\`\`
${conditions ? `\n## Conditions\n${JSON.stringify(conditions, null, 2)}` : ''}
${videoHashCid ? `\n## Video\n\`${videoHashCid}\`` : ''}

## Licensing
License this skill on-chain via the MoveRegistry program (\`Dp2JcVDt4seef6LbPCtoHiD5nrHkRUFHJdBPdCUTVeDQ\`).

---
*Generated by [Move Registry](https://moveregistry.lovable.app)*
`;

    // Store in Supabase Storage
    const supabaseUrl = Deno.env.get("SUPABASE_URL")!;
    const serviceKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
    const supabase = createClient(supabaseUrl, serviceKey);

    const fileId = crypto.randomUUID();

    // Upload all three files
    const uploads = [
      { path: `metadata/${fileId}.json`, content: JSON.stringify(metadata, null, 2), type: "application/json" },
      { path: `metadata/${fileId}-skill.json`, content: JSON.stringify(skillJson, null, 2), type: "application/json" },
      { path: `metadata/${fileId}-SKILL.md`, content: skillMd, type: "text/markdown" },
    ];

    const urls: Record<string, string> = {};
    for (const { path, content, type } of uploads) {
      const { error: uploadError } = await supabase.storage
        .from("nft-metadata")
        .upload(path, content, { contentType: type, upsert: false });

      if (uploadError) {
        console.error(`Upload error (${path}):`, uploadError);
        return new Response(
          JSON.stringify({ error: `Upload failed (${path}): ${uploadError.message}` }),
          { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } }
        );
      }

      const { data: urlData } = supabase.storage.from("nft-metadata").getPublicUrl(path);
      urls[path] = urlData.publicUrl;
    }

    return new Response(
      JSON.stringify({
        uri: urls[`metadata/${fileId}.json`],
        skillJsonUri: urls[`metadata/${fileId}-skill.json`],
        skillMdUri: urls[`metadata/${fileId}-SKILL.md`],
        metadata,
      }),
      { status: 200, headers: { ...corsHeaders, "Content-Type": "application/json" } }
    );
  } catch (err) {
    console.error("nft-metadata error:", err);
    return new Response(
      JSON.stringify({ error: err.message || "Unknown error" }),
      { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } }
    );
  }
});
